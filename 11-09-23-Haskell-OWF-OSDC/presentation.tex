\documentclass[10pt]{beamer}
\usepackage[frenchb]{babel}
\usepackage[utf8]{inputenc}
\usepackage{ucs}
\usetheme{Madrid}
\usepackage{amsmath,amssymb}
\newtheorem{thrm}{Théorème}

\title[Haskell]{Être paresseux avec classe\\
Une introduction à la programmation fonctionnelle pure en Haskell}
\author{Valentin Robert}
\institute{INRIA}
\date{\today}

\begin{document}



\begin{frame}
\titlepage
\end{frame}



\begin{frame}
\frametitle{Qu'est-ce qu'Haskell ?}

\begin{block}
{Programmation fonctionnelle pure (par défaut)}
\begin{itemize}
\item Définitions plus mathématiques qu'opérationnelles
\item Fonctions d'ordre supérieur
\item Transparence référentielle
\end{itemize}
\end{block}

\pause

\begin{block}
{Évaluation paresseuse}
\begin{itemize}
\item Structures de données infinies
\item Entrées/Sorties paresseuses
\end{itemize}
\end{block}

\pause

\begin{block}
{Typage statique}
\begin{itemize}
\item Types connus à la compilation
\item Inférence de types
\item Polymorphisme paramétrique ("templates", "generics", ...)
\item Polymorphisme ad-hoc ("surcharge")
\end{itemize}
\end{block}
\end{frame}



\begin{frame}
\frametitle{Typage statique}
\begin{block}
{Enjeux}
\begin{itemize}
\item Détecter les erreurs à la compilation
\item Sûreté des types
\item Souplesse, modularité, réutilisabilité
\item Éviter les faux positifs, les faux négatifs
\item Opportunités d'optimisation
\end{itemize}
\end{block}
\end{frame}



\begin{frame}[fragile]
\frametitle{Typage statique}
En Haskell toutes les valeurs sont typées.
\begin{verbatim}
ghci> :t 'a'
'a' :: Char

ghci> :t True
True :: Bool

ghci> :t "HELLO!"
"HELLO!" :: [Char]

ghci> :t 4 == 5
4 == 5 :: Bool
\end{verbatim}
\end{frame}



\begin{frame}[fragile]
\frametitle{Typage statique}
Les fonctions (et opérateurs) sont aussi des valeurs !
\begin{verbatim}
:t isAscii
isAscii :: Char → Bool

:t not
not :: Bool → Bool

:t (&&)
(&&) :: Bool → Bool → Bool
\end{verbatim}
\end{frame}



\begin{frame}[fragile]
\frametitle{Curryfication}
\begin{thrm}
\verb|a → b → c| ≡ \verb|a → (b → c)|
\end{thrm}

\pause

\begin{block}
{Attention !}
\verb|a → b → c| ≢ \verb|(a → b) → c|
\end{block}

\pause

\begin{block}
{Application partielle}
\begin{verbatim}
takePositives = takeWhile (> 0)

ghci> :t takeWhile
takeWhile :: (a → Bool) → [a] → [a]

ghci> :t takePositives
takePositives :: [Integer] → [Integer]

ghci> takePositives [10, 9..]
[10, 9, 8, 7, 6, 5, 4, 3, 2, 1]
\end{verbatim}
\end{block}
\end{frame}



\begin{frame}[fragile]
\frametitle{Fonctions anonymes}
\begin{verbatim}
squareList = map (\x → x * x)

ghci> :t map
map :: (a → b) → [a] → [b]

ghci> :t squareList
squareList :: [Integer] → [Integer]

ghci> squareList [1, 2, 3]
[1, 4, 9]
\end{verbatim}
\end{frame}



\begin{frame}[fragile]
\frametitle{Polymorphisme paramétrique}
\begin{block}
{Types de données paramétrés}
\begin{verbatim}
data Maybe a = | Nothing
               | Just a

data List a = | Empty
              | a `Cons` List a
\end{verbatim}
\end{block}
\begin{block}
{Fonctions polymorphes}
\begin{verbatim}
ghci> :t Just
Just :: a → Maybe a

ghci> :t (:)
(:) :: a → [a] → [a]
\end{verbatim}
\end{block}
Le type est en réalité : \verb|Just :: ∀a. a → Maybe a|
\end{frame}



\begin{frame}[fragile]
\frametitle{Polymorphisme ad-hoc : classes de types}
\begin{block}
{Fonctions surchargées}
\begin{verbatim}
ghci> :t (==)
(==) :: Eq a ⇒ a → a → Bool

ghci> :t (+)
(+) :: Num a ⇒ a → a → a

ghci> :t show
show :: Show a ⇒ a → String
\end{verbatim}
\end{block}
\begin{block}
{Constantes surchargées}
\begin{verbatim}
ghci> :t 1
1 :: Num a ⇒ a
\end{verbatim}
\end{block}
Surcharge résolue à la compilation !
\end{frame}



\begin{frame}[fragile]
\frametitle{Polymorphisme ad-hoc : classes de types}
\begin{block}
{Quelques exemples de classes de types de la bibliothèque standard}
\begin{itemize}

\item Eq : \verb|(==), (/=)|

\item Ord : \verb|(<), (>=), (>), (<=), max, min|

\item Num : \verb|(+), (*), (-), negate, abs, ...|

\item Show : \verb|show :: a → String, ...|

\item Read : \verb|read :: String → a, ...|

\end{itemize}
\end{block}
\end{frame}



\begin{frame}[fragile]
\frametitle{Inférence de types}

\begin{verbatim}
fact 0 = 1                  -- 1 :: Num a => a
fact n = n * fact (n-1)     -- (*) :: Num a => a -> a -> a

ghci> :t fact
fact :: Num a ⇒ a → a
\end{verbatim}

Haskell infère le type le plus général !
\end{frame}



\begin{frame}[fragile]
\frametitle{Déclaration d'une classe de type et d'instances de la classe}
\begin{verbatim}
class Eq a where
    (==) :: a → a → Bool
    (/=) :: a → a → Bool
\end{verbatim}
\pause
\begin{verbatim}
    x == y = not (x /= y)
    x /= y = not (x == y)
\end{verbatim}
\pause
\begin{verbatim}
data Color = Red | Green | Blue
    deriving (Eq)

instance Read Color where
    read "R" = Red
    read "G" = Green
    read "B" = Blue
\end{verbatim}
\pause
\begin{verbatim}
ghci> filter (/= Green) $ map read "BRGBBG"
[Blue, Red, Blue, Blue]
\end{verbatim}
\end{frame}




\begin{frame}[fragile]
\frametitle{Classes de types en action}

\verb|[1, 2, 3]| représente \verb|3*x² + 2*x + 1|

\begin{verbatim}
instance Num a => Num [a] where
    (f:fs) + (g:gs) = f+g : fs+gs
    fs + [] = fs
    [] + gs = gs
\end{verbatim}
\pause
\begin{verbatim}
    (f:fs) * (g:gs) = f*g : [f]*gs + fs*(g:gs)
    _ * _ = []
\end{verbatim}
\pause
\begin{verbatim}
    ...
\end{verbatim}

Surcharge automatique :

\begin{verbatim}
ghci> [1, 1] ^ 2    -- (x + 1)² = x² + 2*x + 1
[1, 2, 1]
\end{verbatim}

\pause

Voire :

\begin{verbatim}
ghci> (read "x + 1" :: [a]) ^ 2
x^2 + 2*x + 1
\end{verbatim}

\end{frame}



\begin{frame}[fragile]
\frametitle{Polymorphisme d'ordre supérieur}
\begin{verbatim}
class Functor f where
    fmap :: (a → b) → f a → f b
\end{verbatim}
\pause
\verb|f| n'est pas un type, mais un constructeur de types !
\pause
\begin{verbatim}
instance Functor [] where
    fmap = map
\end{verbatim}
\pause
\begin{verbatim}
instance Functor Maybe where
    fmap f (Just x) = Just (f x)
    fmap f Nothing = Nothing
\end{verbatim}
\end{frame}



\begin{frame}[fragile]
\frametitle{Les actions IO}
\begin{block}
{Contraindre les effets de bord hors du royaume de la pureté}

Sans I/O, pas d'effets, que des maths !

\pause

Avec I/O, pas de transparence référentielle, tout tombe à l'eau !

\pause

\verb|data IO a = RealWorld -> (a, RealWorld)|

\end{block}

\pause

\begin{block}
{Sûreté ?}

\begin{itemize}

\item Non forgeable

\pause

\item Inlavable (aucune fonction n'a pour type \verb|IO a → a|).

\pause

\item Mais composable ! \verb|(>>=) :: IO a → (a → IO b) → IO b|.

\end{itemize}

IO un jour, IO toujours.

\end{block}

\verb|main :: IO ()|

\end{frame}



\begin{frame}[fragile]
\frametitle{Les actions IO}
\begin{verbatim}
ghci> :t (>>=)
(>>=) :: Monad m ⇒ m a → (a → m b) → m b
-- Pensez plutôt à IO a → (a → IO b) → IO b
\end{verbatim}
\pause
\begin{verbatim}
ghci> :t getLine
getLine :: IO String

ghci> :t readFile
readFile :: String → IO String

ghci> :t putStr
putStr :: String → IO ()
\end{verbatim}
\pause
\begin{verbatim}
printFile = getLine >>= readFile >>= putStr

ghci> :t printFile
printFile :: IO ()
\end{verbatim}
\end{frame}



\begin{frame}[fragile]
\frametitle{Les actions IO}

Rappel : \verb|(>>=) :: Monad m ⇒ m a → (a → m b) → m b|

\begin{verbatim}
main = getLine                    >>= (\fileName ->
       doesFileExist fileName     >>= (\fileExists ->
       if fileExists
       then (
                readFile fileName >>= (\fileContents ->
                putStrLn fileContents)
            )
       else putStrLn "File not found!"))
\end{verbatim}

\pause

Sucre syntaxique :

\begin{verbatim}
printFile = do fileName     <- getLine
               fileExists   <- doesFileExist fileName
               if fileExists
               then do fileContents <- readFile fileName
                       putStrLn fileContents
               else putStrLn "File not found!"
\end{verbatim}

On peut en quelque sorte surcharger "=" et ";" !

\end{frame}



\begin{frame}[fragile]
\frametitle{Ce qui a l'air séquentiel ne l'est pas forcément !}
\begin{verbatim}
cartesianProduct l1 l2 =
    do x <- l1
       y <- l2
       return (x, y)

ghci> cartesianProduct [1, 2, 3, 4] [True, False]
[(1,True),(1,False),(2,True),(2,False),(3,True),(3,False)]
\end{verbatim}

\pause

\begin{verbatim}
cartesianProduct' l1 l2 = [(x, y) | x <- l1, y <- l2]
\end{verbatim}

\pause

\begin{verbatim}
ghci> :t cartesianProduct
cartesianProduct :: Monad m ⇒ m t → m t1 → m (t, t1)
\end{verbatim}

\end{frame}



\begin{frame}[fragile]
\frametitle{Exemple de structure d'un programme Haskell}
\begin{verbatim}
main = forever $ do input <- performInput
                    let output = transform input
                    performOutput output
\end{verbatim}

\verb|main :: IO ()| est une action composée par des sous-actions.

\verb|performInput :: IO a|

\verb|transform :: a → b| est une transformation pure !

\verb|performOutput :: b → IO ()|

\pause

\begin{verbatim}
forever :: (Monad m) ⇒ m a → m b
forever a = a >> forever a
\end{verbatim}

Drôle de bête !

\end{frame}



\begin{frame}[fragile]
\frametitle{Exemple de possibilités de programme}
\begin{verbatim}
main = do byteString <- B.readFile "/dev/urandom"
          let string = C.unpack byteString
          putStrLn (take 10 (filter isAlphaNum string))
\end{verbatim}

Paresse en (in-)action !

\verb|unpack :: ByteString → String| est une fonction pure !

\begin{verbatim}
ghci> main
ZwBÛAãÅWóÕ
ghci> main
Fh0iXXïZìæ
\end{verbatim}
\end{frame}



\begin{frame}
\centerline{Question time!}
\end{frame}



\end{document}
