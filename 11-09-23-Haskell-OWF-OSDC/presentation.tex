\documentclass[10pt]{beamer}
\usepackage[frenchb]{babel}
\usepackage[utf8]{inputenc}
\usepackage{ucs}
\usetheme{Madrid}
\usepackage{amsmath,amssymb}
\newtheorem{thrm}{Théorème}

\title[Haskell]{Être paresseux avec classe\\
Une introduction à la programmation fonctionnelle pure en Haskell}
\author{Valentin Robert}
\institute{INRIA}
\date{23 septembre 2011}

\begin{document}



\begin{frame}
\titlepage
\end{frame}



\begin{frame}
\frametitle{Qu'est-ce qu'Haskell ?}

\begin{itemize}

\item Haskell est fonctionnel

\pause

\item Haskell est paresseux

\pause

\item Haskell est pur

\pause

\item Haskell est d'ordre supérieur

\pause

\item Haskell est typé statiquement (et fortement)

\end{itemize}

\end{frame}



\begin{frame}[fragile]
\frametitle{Typage statique}
En Haskell toutes les valeurs sont typées.
\begin{verbatim}
ghci> :t 'a'
'a' :: Char

ghci> :t True
True :: Bool

ghci> :t "HELLO!"
"HELLO!" :: [Char]

ghci> :t 4 == 5
4 == 5 :: Bool
\end{verbatim}
\end{frame}



\begin{frame}[fragile]
\frametitle{Typage statique}
Les fonctions (et opérateurs) sont aussi des valeurs !
\begin{verbatim}
:t isAscii
isAscii :: Char → Bool

:t not
not :: Bool → Bool

:t (&&)
(&&) :: Bool → Bool → Bool
\end{verbatim}
\end{frame}



\begin{frame}[fragile]
\frametitle{Curryfication}
\begin{thrm}
\verb|a → b → c| ≡ \verb|a → (b → c)|
\end{thrm}

\pause

\begin{block}
{Attention !}
\verb|a → b → c| ≢ \verb|(a → b) → c|
\end{block}

\pause

\begin{block}
{Application partielle}
\begin{verbatim}
takePositives = takeWhile (> 0)
\end{verbatim}
\pause
\begin{verbatim}
ghci> :t takeWhile
takeWhile :: (a → Bool) → [a] → [a]
\end{verbatim}
\pause
\begin{verbatim}
ghci> :t takePositives
takePositives :: [Integer] → [Integer]
\end{verbatim}
\pause
\begin{verbatim}
ghci> takePositives [10, 9..]
[10, 9, 8, 7, 6, 5, 4, 3, 2, 1]
\end{verbatim}
\end{block}
\end{frame}



\begin{frame}[fragile]
\frametitle{Fonctions anonymes}
\begin{verbatim}
squareList = map (\x → x * x)
\end{verbatim}
\pause

\begin{verbatim}
ghci> :t map
map :: (a → b) → [a] → [b]
\end{verbatim}
\pause

\begin{verbatim}
ghci> :t squareList
squareList :: [Integer] → [Integer]
\end{verbatim}
\pause

\begin{verbatim}
ghci> squareList [1, 2, 3]
[1, 4, 9]
\end{verbatim}
\end{frame}



\begin{frame}[fragile]
\frametitle{Polymorphisme paramétrique}
\begin{block}
{Types de données paramétrés}
\begin{verbatim}
data Maybe a = Nothing
             | Just a

data [a] = []       -- "nil"
         | a : [a]  -- "cons"

data Stack w = MkStk [w] [w]
\end{verbatim}
\end{block}
\pause
\begin{block}
{Fonctions polymorphes}
\begin{verbatim}
focusPrev :: Stack w → Stack w
focusPrev (MkStk (l:ls) rs) = MkStk ls (l:rs)
focusPrev (MkStk []     rs) =
    case (reverse rs) of
        (l:ls) → MkStk ls [l]
        []     → MkStk [] []
\end{verbatim}
\end{block}
Le type est en réalité : \verb|focusPrev :: ∀w. Stack w → Stack w|
\end{frame}



\begin{frame}[fragile]
\frametitle{Abstraction via les types de données}
\begin{block}
{Module fournisseur}
Export sélectif
\begin{verbatim}
module Stack (Stack, focusNext, focusPrev, ...) where

data Stack = ...
\end{verbatim}
\end{block}
\begin{block}
{Module client}
\begin{verbatim}
module Operations(...) where

import Stack (Stack, focusNext) -- import sélectif

f :: Stack w → Stack w         -- OK : Stack est importé
f (MkStk as bs) = ...           -- NON : MkStk n'est pas importé
\end{verbatim}
\end{block}
\end{frame}



\begin{frame}[fragile]
\frametitle{Besoin de classes de types}
\begin{verbatim}
delete :: Stack w → w → Stack w
\end{verbatim}

\pause

\begin{verbatim}
delete :: ∀w. Stack w → w → Stack w
\end{verbatim}

Possible pour TOUT w ?

\pause

Non ! On doit pouvoir tester l'égalité.

\pause

\begin{verbatim}
sort :: [a] → [a]
\end{verbatim}

Possible pour TOUT a ?

\pause

Non ! Il doit exister un ordre total sur les a.

\pause

\begin{verbatim}
square :: n → n
\end{verbatim}

Devrait marche sur n'importe quel type numérique : Int, Integer, Float, Double,
Rational, ... (Vector, Matrix ?)

\end{frame}




\begin{frame}[fragile]
\frametitle{Polymorphisme ad-hoc : classes de types}
\begin{block}
{Fonctions surchargées}
\begin{verbatim}
delete :: ∀w. Eq w ⇒ Stack w → w → Stack w

sort :: Ord a ⇒ [a] → [a]

square :: Num n ⇒ n → n
\end{verbatim}
\end{block}
\pause
\begin{block}
{Constantes surchargées}
\begin{verbatim}
ghci> :t 1
1 :: Num a ⇒ a
\end{verbatim}
\end{block}
\pause
Surcharge résolue à la compilation !
\end{frame}



\begin{frame}[fragile]
\frametitle{Classes de types et instances}
\begin{verbatim}
data Color = Red | Green | Blue
    deriving (Eq)
\end{verbatim}

\begin{verbatim}
class Read a where
    read :: a → String
\end{verbatim}
\pause
\begin{verbatim}
instance Read Color where
    read "R" = Red
    read "G" = Green
    read "B" = Blue
\end{verbatim}
\pause
\begin{verbatim}
ghci> filter (/= Green) $ map read "BRGBBG"
[Blue, Red, Blue, Blue]
\end{verbatim}
\end{frame}



\begin{frame}[fragile]
\frametitle{Construire de plus grandes instances}
\begin{verbatim}
class Eq a where
    (==) :: a → a → Bool

instance Eq a => Eq [a] where
    (==) []     []      = True
    (==) (x:xs) (y:ys)  = x==y && xs==ys
    (==) _      _       = False
\end{verbatim}
\end{frame}




\begin{frame}[fragile]
\frametitle{Classes de types en action}

\verb|[1, 2, 3]| représente \verb|3*x² + 2*x + 1|

\begin{verbatim}
instance Num a ⇒ Num [a] where
    (f:fs) + (g:gs) = f+g : fs+gs
    fs + [] = fs
    [] + gs = gs
\end{verbatim}
\pause
\begin{verbatim}
    (f:fs) * (g:gs) = f*g : [f]*gs + fs*(g:gs)
    _ * _ = []
\end{verbatim}
\pause
\begin{verbatim}
    ...
\end{verbatim}

Surcharge automatique :

\begin{verbatim}
ghci> [1, 1] ^ 2    -- (x + 1)² = x² + 2*x + 1
[1, 2, 1]
\end{verbatim}

\pause

Voire :

\begin{verbatim}
ghci> (read "x + 1" :: [a]) ^ 2
x^2 + 2*x + 1
\end{verbatim}

\end{frame}



\begin{frame}[fragile]
\frametitle{Inférence de types}

\begin{verbatim}
fact 0 = 1                  -- 1 :: Num a ⇒ a
fact n = n * fact (n-1)     -- (*) :: Num a ⇒ a → a → a
\end{verbatim}
\pause
\begin{verbatim}
ghci> :t fact
fact :: Num a ⇒ a → a
\end{verbatim}

Haskell infère le type le plus général !
\end{frame}



\begin{frame}[fragile]
\frametitle{Polymorphisme d'ordre supérieur}
\begin{verbatim}
class Functor f where
    fmap :: (a → b) → f a → f b
\end{verbatim}
\pause
\verb|f| n'est pas un type, mais un constructeur de types !
\pause
\begin{verbatim}
instance Functor [] where
    fmap = map
\end{verbatim}
\pause
\begin{verbatim}
instance Functor Maybe where
    fmap f (Just x) = Just (f x)
    fmap f Nothing = Nothing
\end{verbatim}
\end{frame}



\begin{frame}[fragile]
\frametitle{Les actions IO}
\begin{block}
{Contraindre les effets de bord hors du royaume de la pureté}

Sans I/O, pas d'effets, que des maths !

\pause

Avec I/O, pas de transparence référentielle, tout tombe à l'eau !

\pause

\verb|data IO a = RealWorld → (a, RealWorld)|

\end{block}

\pause

\begin{block}
{Sûreté ?}

\begin{itemize}

\item Non forgeable

\pause

\item Inlavable (aucune fonction n'a pour type \verb|IO a → a|).

\pause

\item Mais composable ! \verb|(>>=) :: IO a → (a → IO b) → IO b|.

\end{itemize}

IO un jour, IO toujours.

\end{block}

\verb|main :: IO ()|

\end{frame}



\begin{frame}[fragile]
\frametitle{Les actions IO}
\begin{verbatim}
ghci> :t (>>=)
(>>=) :: Monad m ⇒ m a → (a → m b) → m b
-- Pensez plutôt à IO a → (a → IO b) → IO b
\end{verbatim}
\pause
\begin{verbatim}
ghci> :t getLine
getLine :: IO String

ghci> :t readFile
readFile :: String → IO String

ghci> :t putStr
putStr :: String → IO ()
\end{verbatim}
\pause
\begin{verbatim}
printFile = getLine >>= readFile >>= putStr

ghci> :t printFile
printFile :: IO ()
\end{verbatim}
\end{frame}



\begin{frame}[fragile]
\frametitle{Les actions IO}

Rappel : \verb|(>>=) :: Monad m ⇒ m a → (a → m b) → m b|

\begin{verbatim}
main = getLine                    >>= (\fileName →
       doesFileExist fileName     >>= (\fileExists →
       if fileExists
       then (
                readFile fileName >>= (\fileContents →
                putStrLn fileContents)
            )
       else putStrLn "File not found!"))
\end{verbatim}

\pause

Sucre syntaxique :

\begin{verbatim}
printFile = do fileName     <- getLine
               fileExists   <- doesFileExist fileName
               if fileExists
               then do fileContents <- readFile fileName
                       putStrLn fileContents
               else putStrLn "File not found!"
\end{verbatim}

On peut en quelque sorte surcharger "=" et ";" !

\end{frame}



\begin{frame}[fragile]
\frametitle{Ce qui a l'air séquentiel ne l'est pas forcément !}
\begin{verbatim}
cartesianProduct l1 l2 =
    do x <- l1
       y <- l2
       return (x, y)

ghci> cartesianProduct [1, 2, 3, 4] [True, False]
[(1,True),(1,False),(2,True),(2,False),(3,True),(3,False)]
\end{verbatim}

\pause

\begin{verbatim}
cartesianProduct' l1 l2 = [(x, y) | x <- l1, y <- l2]
\end{verbatim}

\pause

\begin{verbatim}
ghci> :t cartesianProduct
cartesianProduct :: Monad m ⇒ m t → m t1 → m (t, t1)
\end{verbatim}

\end{frame}



\begin{frame}[fragile]
\frametitle{Exemple de structure d'un programme Haskell}
\begin{verbatim}
main = forever $ do input <- performInput
                    let output = transform input
                    performOutput output
\end{verbatim}

\begin{verbatim}
main :: IO ()

performInput :: IO a

transform :: a → b

performOutput :: b → IO ()
\end{verbatim}

\pause

\begin{verbatim}
forever :: (Monad m) ⇒ m a → m b
forever a = a >> forever a
\end{verbatim}

\end{frame}



\begin{frame}[fragile]
\frametitle{Exemple de possibilités de programme}
\begin{verbatim}
main = do byteString <- B.readFile "/dev/urandom"
          let string = C.unpack byteString
          putStrLn (take 10 (filter isAlphaNum string))
\end{verbatim}

Paresse en (in-)action !

\verb|unpack :: ByteString → String| est une fonction pure !

\begin{verbatim}
ghci> main
ZwBÛAãÅWóÕ
ghci> main
Fh0iXXïZìæ
\end{verbatim}
\end{frame}



\begin{frame}[fragile]
\frametitle{Les fonctions pures sont simples à tester !}
\begin{block}{Code}
\begin{verbatim}
focusPrev :: Stack w -> Stack w

focusNext :: Stack w -> Stack w
\end{verbatim}
\end{block}
\pause
\begin{block}{Propriétés}
\begin{verbatim}
prop_focus :: Stack w -> Bool
prop_focus s = s == focusNext . focusPrev $ s
--          ou (s == (focusNext (focusPrev s)))
--          si vous aimez les parenthèses...
\end{verbatim}
\end{block}
\end{frame}




\begin{frame}[fragile]
\frametitle{Quickcheck en une poignée de lignes !}

\begin{block}{Code}
\begin{verbatim}
quickCheck :: Testable a => a -> IO ()

class Testable a where
    test :: a -> RandSupply -> Bool

class Arbitrary a where
    arby :: RandSupply -> a

instance Testable Bool where
    test b r = b

instance (Arbitrary a, Testable b) => Testable (a -> b) where
    test f r = test (f (arby r1)) r2
        where (r1, r2) = split r
\end{verbatim}
\end{block}

\begin{verbatim}
> quickCheck prop_focus
OK, passed 100 tests.
\end{verbatim}

\end{frame}



\begin{frame}[fragile]
\frametitle{Instance de Quickcheck}
\begin{block}{Implémentation}
\begin{verbatim}
instance Arbitrary Int where
    arby r = randInt r

instance Arbitrary a => Arbitrary [a] where
    arby r | even r1   = []
           | otherwise = arby r2 : arby r3
        where (r1, r') = split r
              (r2, r3) = split r'

instance Arbitrary a => Arbitrary (Stack a) where
    arby r = MkStk (arby r1) (arby r2)
        where (r1, r2) = split r

split :: RandSupply -> (RandSupply, RandSupply)
\end{verbatim}
\end{block}
\end{frame}



\begin{frame}[fragile]
\frametitle{Scripter en Haskell}
\begin{block}{Partie impure}
\begin{verbatim}
main :: IO ()
main = do as <- getArgs
          mapM_ process as

process :: String -> IO ()
process file =
  do cts <- readFile file
     let tests = getTests cts
     if null tests then
       putStrLn (file ++ ": no properties to check")
     else do
       writeFile "script" $
         unlines ([":l " ++ file] ++ concatMap makeTest tests)
       system ("ghci -v0 < script")
       return ()
\end{verbatim}
\end{block}
\end{frame}



\begin{frame}[fragile]
\frametitle{Scripter en Haskell}
\begin{block}{Partie pure}
\begin{verbatim}
getTests :: String -> [String]
getTests cts = nub
               . filter ("prop_" `isPrefixOf`)
               . map (fst . head . lex)
               $ lines cts

makeTest :: String -> [String]
makeTest test = ["putStr \"" ++ test ++ ": \"", “quickCheck " ++
                  test]
\end{verbatim}
\end{block}
\end{frame}



\begin{frame}
\centerline{Merci de votre attention, place aux questions !}

\begin{figure}
\includegraphics[scale=0.4]{haskell_fr_logo.png}
\end{figure}

\centerline{Nouveau ! \url{http://haskell.fr}}

\centerline{Nouveau ! \url{http://lyah.haskell.fr}}
\end{frame}



\end{document}
